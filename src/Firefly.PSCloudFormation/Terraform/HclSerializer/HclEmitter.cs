namespace Firefly.PSCloudFormation.Terraform.HclSerializer
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text.RegularExpressions;

    using Amazon.S3.Transfer;

    using Firefly.PSCloudFormation.Terraform.HclSerializer.Events;
    using Firefly.PSCloudFormation.Terraform.HclSerializer.Schema;

    /// <summary>
    /// HCL Emitter. Inspired by <c>YamlDotNet</c> emitter.
    /// Handles emitting of resources to HCL from events generated by reading the state file.
    /// - All mappings at top level in a resource are blocks, unless explicitly _not_ blocks (e.g. "ingress", "egress" in SG)
    /// - Blocks can be nested
    /// - All other mappings are mappings
    /// - Blocks may or may not contain a sequence in state file:
    ///   - Block, Object (e.g. "timeouts") = no sequence
    ///   - Block, List|Set = sequence
    /// - Multiple sequence values for a block are emitted as multiple instances of the block
    /// </summary>
    /// <seealso cref="Firefly.PSCloudFormation.Terraform.HclSerializer.IHclEmitter" />
    internal class HclEmitter : IHclEmitter
    {
        /// <summary>
        /// Matches tokens embedded in scalars that should not be treated as interpolations.
        /// </summary>
        private static readonly Regex NonInterpolatedTokenRegex = new Regex(@"(?<token>\$\{[^.\}]+\})");

        /// <summary>
        /// When these attributes are present, emit a lifecycle block to prevent it looking like these resources need replacing
        /// since these attributes don't get correctly imported to state.
        /// </summary>
        private static readonly Dictionary<string, List<string>> EmitLifecycle = new Dictionary<string, List<string>>
            {
                { "aws_instance", new List<string> { "user_data", "user_data_base64" } },
                { "aws_launch_configuration", new List<string> { "user_data", "user_data_base64" } },
            };

        /// <summary>
        /// Stack of nested block keys
        /// </summary>
        private readonly Stack<MappingKey> blockKeys = new Stack<MappingKey>();

        /// <summary>
        /// Queue of events to process
        /// </summary>
        private readonly EventQueue events = new EventQueue();

        /// <summary>
        /// Stack of indent levels
        /// </summary>
        private readonly Stack<int> indents = new Stack<int>();

        /// <summary>
        /// Sink for HCL output
        /// </summary>
        private readonly TextWriter output;

        /// <summary>
        /// Stack of states processed as emitter descends object graph
        /// </summary>
        private readonly Stack<EmitterState> states = new Stack<EmitterState>();

        /// <summary>
        /// The current column number in the output
        /// </summary>
        private int column;

        /// <summary>
        /// The current block key if emitting a block
        /// </summary>
        private MappingKey currentBlockKey;

        /// <summary>
        /// The current attribute path
        /// </summary>
        private string currentPath;

        /// <summary>
        /// The current resource name
        /// </summary>
        private string currentResourceName;

        /// <summary>
        /// The current resource type
        /// </summary>
        private string currentResourceType;

        /// <summary>
        /// The current indent level (in chars)
        /// </summary>
        private int indent;

        /// <summary>
        /// Whether the last thing emitted was an indentation
        /// </summary>
        private bool isIndentation;

        /// <summary>
        /// <c>true</c> when emitting a <c>jsonencode</c> block
        /// </summary>
        private bool isJson;

        /// <summary>
        /// Whether the last thing emitted was whitespace.
        /// </summary>
        private bool isWhitespace;

        /// <summary>
        /// The previous state of the emitter
        /// </summary>
        private EmitterState previousState;

        /// <summary>
        /// The resource traits for the current resource being serialized.
        /// </summary>
        private IResourceTraits resourceTraits;

        /// <summary>
        /// Current state of the emitter.
        /// </summary>
        private EmitterState state;

        /// <summary>
        /// At end of resource, if this contains any items, emit a lifecycle block.
        /// </summary>
        private List<string> lifecycleKeys = new List<string>();

        /// <summary>
        /// Initializes a new instance of the <see cref="HclEmitter"/> class.
        /// </summary>
        /// <param name="output">The output stream.</param>
        public HclEmitter(TextWriter output)
        {
            this.output = output;
            this.state = EmitterState.Resource;
            this.resourceTraits = AwsSchema.TraitsAll;
        }

        /// <summary>
        /// States the emitter can be in
        /// </summary>
        private enum EmitterState
        {
            /// <summary>
            /// At top level resource attributes
            /// </summary>
            Resource,

            /// <summary>
            /// In a regular mapping type, like tags.
            /// </summary>
            Mapping,

            /// <summary>
            /// In a sequence
            /// </summary>
            Sequence,

            /// <summary>
            /// In a JSON block (<c>jsonencode</c>)
            /// </summary>
            Json,

            /// <summary>
            /// In a block set/list definition where there is a sequence of repeating blocks.
            /// </summary>
            BlockList,

            /// <summary>
            /// In a block mapping that has no embedded sequence component, like 'timeouts'
            /// </summary>
            BlockObject
        }

        /// <summary>
        /// Emits the next event.
        /// Events are queued until an entire resource is collected, the that resource is written out.
        /// </summary>
        /// <param name="event">The event.</param>
        public void Emit(HclEvent @event)
        {
            this.events.Enqueue(@event);

            if (@event.Type != EventType.ResourceEnd)
            {
                return;
            }

            try
            {
                // Eliminate attributes we don't want to serialize,
                // thus everything remaining in the queue following
                // this operation will be emitted.
                new EventQueuePreprocessor(this.events).ProcessQueue();

                this.state = EmitterState.Resource;
                while (this.events.Any())
                {
                    this.EmitNode(this.events.Dequeue());
                }
            }
            catch (HclSerializerException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new HclSerializerException(
                    $"Internal error: {e.Message}",
                    this.currentResourceName,
                    this.currentResourceType,
                    e);
            }
        }

        /// <summary>
        /// Asserts an event is of the requested type and casts to it.
        /// </summary>
        /// <typeparam name="T">Expected subtype of the event passed as argument.</typeparam>
        /// <param name="event">The event.</param>
        /// <returns>Type casted event.</returns>
        /// <exception cref="System.ArgumentException">Expected {typeof(T).Name} - event</exception>
        private static T GetTypedEvent<T>(HclEvent @event)
            where T : HclEvent
        {
            if (!(@event is T hclEvent))
            {
                throw new ArgumentException($"Expected {typeof(T).Name}", nameof(@event));
            }

            return hclEvent;
        }

        /// <summary>
        /// Emits a policy end.
        /// </summary>
        /// <param name="event">The event.</param>
        private void EmitJsonEnd(HclEvent @event)
        {
            GetTypedEvent<JsonEnd>(@event);

            this.isJson = false;
            this.indent = this.indents.Pop();
            this.state = this.PopState();
            this.WriteIndent();
            this.WriteIndicator(")", false, false, false);

            if (this.state == EmitterState.Sequence)
            {
                this.Write(',');
            }
        }

        /// <summary>
        /// Emits a policy start.
        /// </summary>
        /// <param name="event">The event.</param>
        private void EmitJsonStart(HclEvent @event)
        {
            GetTypedEvent<JsonStart>(@event);

            this.isJson = true;
            this.PushState(this.state);
            this.state = EmitterState.Json;
            this.WriteIndicator("jsonencode(", true, false, true);
            this.IncreaseIndent();
            this.WriteIndent();
        }

        /// <summary>
        /// Emits a mapping end.
        /// </summary>
        /// <param name="event">The event.</param>
        private void EmitMappingEnd(HclEvent @event)
        {
            GetTypedEvent<MappingEnd>(@event);

            if (this.state != EmitterState.Resource)
            {
                this.state = this.PopState();
            }

            if (this.state == EmitterState.Resource && this.lifecycleKeys.Any())
            {
                /*
                    Needs to go ahead of ResourceEnd which should be next

                    BlockKey  (lifecycle)
                    SequenceStart
                    MappingStart 
                    MappingKey (ignore_changes )
                    SequenceStart
                    Scalar (unquoted) 
                    ...
                    SequenceEnd
                    MappingEnd
                    SequenceEnd
                    MappingEnd (end of resource)

                 */
                var resourceEnd = this.events.Dequeue();

                this.events.Enqueue(
                    new MappingKey(
                        "lifecycle",
                        new AttributePath("lifecycle"),
                        new ValueSchema { Optional = true, ConfigMode = SchemaConfigMode.SchemaConfigModeBlock, Type = SchemaValueType.TypeList }));
                this.events.Enqueue(new SequenceStart());
                this.events.Enqueue(new MappingStart());
                this.events.Enqueue(
                    new MappingKey(
                        "ignore_changes",
                        new AttributePath("lifecycle.0.ignore_changes"),
                        new ValueSchema { Optional = true, ConfigMode = SchemaConfigMode.SchemaConfigModeAuto }));
                this.events.Enqueue(new SequenceStart());

                foreach (var key in this.lifecycleKeys)
                {
                    this.events.Enqueue(new ScalarValue(key, false));
                }

                this.events.Enqueue(new SequenceEnd());
                this.events.Enqueue(new MappingEnd());
                this.events.Enqueue(new SequenceEnd());
                this.events.Enqueue(new MappingEnd());
                this.events.Enqueue(resourceEnd);
                this.lifecycleKeys.Clear();
                return;
            }

            this.indent = this.indents.Pop();

            this.WriteIndent();
            this.WriteIndicator("}", false, false, true);

            var mappingStart = this.events.Peek() as MappingStart;

            // ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
            switch (this.state)
            {
                case EmitterState.BlockList when mappingStart != null:

                    // Next element in a block list
                    this.WriteIndent();
                    this.indent = this.indents.Pop();
                    this.EmitMappingKey(this.currentBlockKey);
                    this.IncreaseIndent();

                    return;

                case EmitterState.Sequence when mappingStart != null:

                    this.Write(',');
                    this.WriteIndent();
                    break;
            }
        }

        /// <summary>
        /// Emits a mapping key.
        /// </summary>
        /// <param name="event">A <see cref="MappingKey"/> event.</param>
        private void EmitMappingKey(HclEvent @event)
        {
            var key = GetTypedEvent<MappingKey>(@event);

            if (EmitLifecycle.ContainsKey(this.currentResourceType)
                && EmitLifecycle[this.currentResourceType].Contains(key.Path))
            {
                this.lifecycleKeys.Add(key.Path);
            }

            // Don't push path for repeating block key
            if (!key.IsBlockKey)
            {
                if (!this.isJson)
                {
                    this.currentPath = key.Path;
                }

                this.WriteIndent();
            }
            else
            {
                // ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
                switch (key.InitialAnalysis)
                {
                    case AttributeContent.BlockList:

                        this.blockKeys.Push(key);
                        this.currentBlockKey = key;
                        this.PushState(this.state);
                        this.state = EmitterState.BlockList;
                        break;

                    case AttributeContent.BlockObject:

                        this.state = EmitterState.BlockObject;
                        break;

                    default:

                        this.state = EmitterState.Mapping;
                        break;
                }

                this.WriteBreak();
                this.WriteIndent();
            }

            this.EmitScalar(@event);

            if (this.state == EmitterState.Mapping)
            {
                this.WriteIndicator("=", true, false, false);
            }
        }

        /// <summary>
        /// Emits a mapping start.
        /// </summary>
        /// <param name="event">A <see cref="MappingStart"/> event.</param>
        private void EmitMappingStart(HclEvent @event)
        {
            GetTypedEvent<MappingStart>(@event);

            this.PushState(this.state);
            this.state = EmitterState.Mapping;
            this.WriteIndicator("{", true, false, false);
            this.IncreaseIndent();
            this.WriteIndent();
        }

        /// <summary>
        /// Emits the next node.
        /// </summary>
        /// <param name="event">The event to write.</param>
        private void EmitNode(HclEvent @event)
        {
            // ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
            switch (@event.Type)
            {
                case EventType.ResourceStart:

                    this.EmitResourceStart(@event);
                    break;

                case EventType.MappingKey:

                    this.EmitMappingKey(@event);
                    break;

                case EventType.ScalarValue:

                    this.EmitScalarValue(@event);
                    break;

                case EventType.SequenceStart:

                    this.EmitSequenceStart(@event);
                    break;

                case EventType.SequenceEnd:

                    this.EmitSequenceEnd(@event);
                    break;

                case EventType.MappingStart:

                    this.EmitMappingStart(@event);
                    break;

                case EventType.MappingEnd:

                    this.EmitMappingEnd(@event);
                    break;

                case EventType.JsonStart:

                    this.EmitJsonStart(@event);
                    break;

                case EventType.JsonEnd:

                    this.EmitJsonEnd(@event);
                    break;

                case EventType.ResourceEnd:

                    this.indents.Clear();
                    this.lifecycleKeys.Clear();
                    this.blockKeys.Clear();
                    this.column = 0;
                    this.indent = 0;
                    this.resourceTraits = AwsSchema.TraitsAll;
                    this.WriteBreak();
                    this.WriteBreak();
                    break;
            }
        }

        /// <summary>
        /// Emits the resource start.
        /// </summary>
        /// <param name="event">A <see cref="ResourceStart"/> event.</param>
        private void EmitResourceStart(HclEvent @event)
        {
            var rs = GetTypedEvent<ResourceStart>(@event);

            this.Write("resource");
            this.isWhitespace = false;
            this.resourceTraits = AwsSchema.GetResourceTraits(rs.ResourceType);
            this.currentResourceName = rs.ResourceName;
            this.currentResourceType = rs.ResourceType;
            this.EmitScalar(new Scalar(rs.ResourceType, true));
            this.EmitScalar(new Scalar(rs.ResourceName, true));
        }

        /// <summary>
        /// Emits a scalar.
        /// </summary>
        /// <param name="event">The event.</param>
        private void EmitScalar(HclEvent @event)
        {
            var scalar = GetTypedEvent<Scalar>(@event);

            if (!this.isWhitespace)
            {
                this.Write(' ');
            }

            var value = NonInterpolatedTokenRegex.Replace(scalar.Value, match => "$" + match.Groups["token"].Value);

            if (value.Any(char.IsControl))
            {
                // The Unicode standard classifies the characters \u000A (LF), \u000C (FF), and \u000D (CR) as control characters
                // Emit as here doc
                this.Write("<<-EOT");
                foreach (var line in value.Split('\r', '\n'))
                {
                    this.WriteIndent();
                    this.Write(line);
                }

                this.WriteIndent();
                this.Write("EOT");
            }
            else
            {
                if (scalar.IsQuoted)
                {
                    this.Write('"');
                }

                this.Write(value);

                if (scalar.IsQuoted)
                {
                    this.Write('"');
                }
            }

            if (this.state == EmitterState.Sequence)
            {
                this.Write(',');
            }

            this.isWhitespace = false;
        }

        /// <summary>
        /// Emits a scalar value.
        /// </summary>
        /// <param name="event">A <see cref="ScalarValue"/> event.</param>
        private void EmitScalarValue(HclEvent @event)
        {
            var scalar = GetTypedEvent<ScalarValue>(@event);

            if (this.state == EmitterState.Sequence)
            {
                this.WriteIndent();
            }

            this.EmitScalar(this.resourceTraits.ApplyDefaultValue(this.currentPath, scalar));
        }

        /// <summary>
        /// Emits a sequence end.
        /// </summary>
        /// <param name="event">The event.</param>
        private void EmitSequenceEnd(HclEvent @event)
        {
            GetTypedEvent<SequenceEnd>(@event);

            this.state = this.PopState();

            if (this.previousState == EmitterState.BlockList)
            {
                // End of block list
                while (this.state == EmitterState.BlockList)
                {
                    this.state = this.PopState();
                }

                return;
            }

            this.indent = this.indents.Pop();
            this.WriteIndent();
            this.WriteIndicator("]", false, false, false);

            if (this.state == EmitterState.Sequence)
            {
                this.Write(',');
            }
        }

        /// <summary>
        /// Emits a sequence start.
        /// </summary>
        /// <param name="event">The event.</param>
        private void EmitSequenceStart(HclEvent @event)
        {
            GetTypedEvent<SequenceStart>(@event);

            if (this.events.Peek() is SequenceEnd)
            {
                // Write empty sequence
                this.WriteIndicator("[]", true, false, true);
                this.WriteIndent();

                // ...and remove SequenceEnd
                this.events.Dequeue();
                return;
            }

            if (this.state == EmitterState.BlockList)
            {
                // BlockList state will be pushed at start of mapping
                return;
            }

            this.PushState(this.state);

            this.WriteIndicator("[", true, false, true);
            this.IncreaseIndent();
            this.WriteIndent();
            this.state = EmitterState.Sequence;
        }

        /// <summary>
        /// Increases the indentation level.
        /// </summary>
        private void IncreaseIndent()
        {
            this.indents.Push(this.indent);
            this.indent += 2;
        }

        /// <summary>
        /// Pop the emitter state and store the previous state.
        /// </summary>
        /// <returns>The next emitter state.</returns>
        private EmitterState PopState()
        {
            this.previousState = this.state;
            return this.states.Pop();
        }

        /// <summary>
        /// Push the current emitter state onto the state stack.
        /// </summary>
        /// <param name="currentState">The current state</param>
        private void PushState(EmitterState currentState)
        {
            this.states.Push(currentState);
        }

        /// <summary>
        /// Writes a character to the output stream
        /// </summary>
        /// <param name="value">The value.</param>
        private void Write(char value)
        {
            this.output.Write(value);
            ++this.column;
        }

        /// <summary>
        /// Writes a string to the output stream.
        /// </summary>
        /// <param name="value">The value.</param>
        private void Write(string value)
        {
            this.output.Write(value);
            this.column += value.Length;
        }

        /// <summary>
        /// Writes a line break to the output stream.
        /// </summary>
        /// <param name="breakCharacter">The break character.</param>
        private void WriteBreak(char breakCharacter = '\n')
        {
            if (breakCharacter == '\n')
            {
                this.output.WriteLine();
            }
            else
            {
                this.output.Write(breakCharacter);
            }

            this.column = 0;
        }

        /// <summary>
        /// Writes indentation to the output stream.
        /// </summary>
        private void WriteIndent()
        {
            var currentIndent = Math.Max(this.indent, 0);

            var isBreakRequired = !this.isIndentation || this.column > currentIndent
                                                      || (this.column == currentIndent && !this.isWhitespace);

            if (isBreakRequired)
            {
                this.WriteBreak();
            }

            while (this.column < currentIndent)
            {
                this.Write(' ');
            }

            this.isWhitespace = true;
            this.isIndentation = true;
        }

        /// <summary>
        /// Writes an indicator (syntactic sugar) to the output stream.
        /// </summary>
        /// <param name="indicator">The indicator.</param>
        /// <param name="needWhitespace">if set to <c>true</c> whitespace should be prepended.</param>
        /// <param name="whitespace">if set to <c>true</c> whitespace is being output.</param>
        /// <param name="indentation">if set to <c>true</c> indentation is being output.</param>
        private void WriteIndicator(string indicator, bool needWhitespace, bool whitespace, bool indentation)
        {
            if (needWhitespace && !this.isWhitespace)
            {
                this.Write(' ');
            }

            this.Write(indicator);

            this.isWhitespace = whitespace;
            this.isIndentation &= indentation;
        }
    }
}